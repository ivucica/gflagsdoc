"""Convert gflags helpxml to markdown.

Usage: python gflagsdoc.py [flags]
"""
from absl import flags
from absl import app
from lxml import etree
import markdown2

infile = flags.DEFINE_string('infile', None, 'Input file path.')
fmt = flags.DEFINE_enum('fmt', 'html', ['markdown', 'html'], 'Output format.')

def xml_to_markdown(xml: str) -> str:
  """Apply xslt to convert xml to markdown.
  
  Args:
    xml: str, xml string.
  
  Returns:
    str, markdown string.
  """
  with open('gflagsxml.xslt', 'rb') as f:
    xslt = f.read()
  xslt_root = etree.XML(xslt)
  transform = etree.XSLT(xslt_root)
  xml_root = etree.XML(xml)
  result = transform(xml_root)
  return str(result)


def markdown_to_html(markdown: str) -> str:
  """Convert markdown to html.
  
  Args:
    markdown: str, markdown string.
  
  Returns:
    str, html string.
  """
  html = markdown2.markdown(markdown)
  return html


def xml_to_html(xml: str) -> str:
  """Convert xml to html.
  
  Args:
    xml: str, xml string.
  
  Returns:
    str, html string.
  """
  markdown = xml_to_markdown(xml)
  html = markdown_to_html(markdown)
  return html


def main(unused_argv):
  """Turn documentation for helpxml into a markdown file.

  From documentation for helpxml in gflags.py:

  OUTPUT FOR --helpxml:

  The --helpxml flag generates output with the following structure:
  <?xml version="1.0"?>
  <AllFlags>
    <program>PROGRAM_BASENAME</program>
    <usage>MAIN_MODULE_DOCSTRING</usage>
    (<flag>
      [<key>yes</key>]
      <file>DECLARING_MODULE</file>
      <name>FLAG_NAME</name>
      <meaning>FLAG_HELP_MESSAGE</meaning>
      <default>DEFAULT_FLAG_VALUE</default>
      <current>CURRENT_FLAG_VALUE</current>
      <type>FLAG_TYPE</type>
      [OPTIONAL_ELEMENTS]
    </flag>)*
  </AllFlags>

  Notes:

  1. The output is intentionally similar to the output generated by the
  C++ command-line flag library.  The few differences are due to the
  Python flags that do not have a C++ equivalent (at least not yet),
  e.g., DEFINE_list.

  2. New XML elements may be added in the future.

  3. DEFAULT_FLAG_VALUE is in serialized form, i.e., the string you can
  pass for this flag on the command-line.  E.g., for a flag defined
  using DEFINE_list, this field may be foo,bar, not ['foo', 'bar'].

  4. CURRENT_FLAG_VALUE is produced using str().  This means that the
  string 'false' will be represented in the same way as the boolean
  False.  Using repr() would have removed this ambiguity and simplified
  parsing, but would have broken the compatibility with the C++
  command-line flags.

  5. OPTIONAL_ELEMENTS describe elements relevant for certain kinds of
  flags: lower_bound, upper_bound (for flags that specify bounds),
  enum_value (for enum flags), list_separator (for flags that consist of
  a list of values, separated by a special token).
  """
  if infile.value is None:
    app.usage(True)
    return

  with open(infile.value, 'rb') as f:
    xml = f.read()
  if fmt.value == 'markdown':
    markdown = xml_to_markdown(xml)
    print(markdown)
  elif fmt.value == 'html':
    html = xml_to_html(xml)
    print(html)
  else:
    raise ValueError(f'Unknown format: {fmt.value}')


if __name__ == '__main__':
  app.run(main)
